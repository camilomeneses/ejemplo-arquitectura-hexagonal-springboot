# üéØ Principios SOLID en Arquitectura Hexagonal - Proyecto Parqueadero

## üìã Introducci√≥n

Este documento analiza c√≥mo se implementan los **5 principios SOLID** en nuestro proyecto de parqueadero usando **Arquitectura Hexagonal** con Spring Boot y Gradle. Cada principio se explica con ejemplos concretos del c√≥digo.

---

## üîç Los 5 Principios SOLID

### 1Ô∏è‚É£ **S** - Single Responsibility Principle (SRP)
> **"Una clase debe tener una sola raz√≥n para cambiar"**

#### ‚úÖ **Aplicaci√≥n en el Proyecto:**

**üéØ ParqueaderoController**
```java
@RestController
@RequestMapping("/api/parqueadero")
public class ParqueaderoController {
    // √öNICA RESPONSABILIDAD: Manejar peticiones HTTP del parqueadero
    // - Recibir requests HTTP
    // - Validar datos de entrada
    // - Delegar al caso de uso
    // - Retornar respuestas HTTP
}
```

**üéØ ParqueaderoService**
```java
@Service
public class ParqueaderoService implements ParqueaderoUseCase {
    // √öNICA RESPONSABILIDAD: L√≥gica de negocio del parqueadero
    // - Validar reglas de negocio
    // - Coordinar operaciones del dominio
    // - Orquestar persistencia
}
```

**üéØ VehiculoRepositoryAdapter**
```java
@Component
public class VehiculoRepositoryAdapter implements VehiculoRepository {
    // √öNICA RESPONSABILIDAD: Adaptaci√≥n entre dominio e infraestructura
    // - Convertir entre entidades del dominio y de persistencia
    // - Delegar operaciones CRUD al JPA Repository
}
```

**üéØ Vehiculo (Domain Model)**
```java
public class Vehiculo {
    // √öNICA RESPONSABILIDAD: Representar y validar un veh√≠culo del dominio
    // - Mantener estado del veh√≠culo
    // - Validar reglas de negocio propias
    // - Factory methods para creaci√≥n
}
```

#### ‚ùå **Violaci√≥n que se evita:**
Sin SRP, tendr√≠amos una clase `ParqueaderoManager` que maneje HTTP, validaciones, l√≥gica de negocio y persistencia.

---

### 2Ô∏è‚É£ **O** - Open/Closed Principle (OCP)
> **"Las entidades deben estar abiertas para extensi√≥n, pero cerradas para modificaci√≥n"**

#### ‚úÖ **Aplicaci√≥n en el Proyecto:**

**üéØ Puerto de Entrada (ParqueaderoUseCase)**
```java
public interface ParqueaderoUseCase {
    Vehiculo ingresarVehiculo(String placa, TipoVehiculo tipo);
    Vehiculo sacarVehiculo(String placa);
    List<Vehiculo> consultarVehiculosActivos();
    // ABIERTO para extensi√≥n: Nuevos casos de uso
    // CERRADO para modificaci√≥n: Interface estable
}
```

**üéØ Puerto de Salida (VehiculoRepository)**
```java
public interface VehiculoRepository {
    Vehiculo guardar(Vehiculo vehiculo);
    Optional<Vehiculo> buscarPorPlaca(String placa);
    // ABIERTO para extensi√≥n: Nuevas implementaciones de persistencia
    // CERRADO para modificaci√≥n: Contrato estable
}
```

**üéØ Enum TipoVehiculo**
```java
public enum TipoVehiculo {
    CARRO(1000),
    MOTO(500);
    // F√ÅCIL EXTENSI√ìN: Agregar BICICLETA(200), CAMION(1500)
    // SIN MODIFICAR c√≥digo existente
}
```

#### üöÄ **Ejemplos de Extensi√≥n sin Modificaci√≥n:**

1. **Nueva implementaci√≥n de persistencia:**
```java
// Nuevo adaptador para MongoDB - SIN modificar c√≥digo existente
@Component
public class VehiculoMongoRepositoryAdapter implements VehiculoRepository {
    // Implementaci√≥n espec√≠fica para MongoDB
}
```

2. **Nuevo tipo de notificaci√≥n:**
```java
// Nuevo caso de uso - SIN modificar ParqueaderoService
@Service
public class NotificacionService implements NotificacionUseCase {
    // L√≥gica de notificaciones
}
```

---

### 3Ô∏è‚É£ **L** - Liskov Substitution Principle (LSP)
> **"Los objetos derivados deben poder sustituir a sus objetos base sin alterar el funcionamiento"**

#### ‚úÖ **Aplicaci√≥n en el Proyecto:**

**üéØ Sustituci√≥n de Implementaciones de Repository**
```java
// El servicio funciona con CUALQUIER implementaci√≥n de VehiculoRepository
@Service
public class ParqueaderoService implements ParqueaderoUseCase {
    private final VehiculoRepository vehiculoRepository; // Interface
    
    // Puede ser JPA, MongoDB, Redis, etc. - comportamiento consistente
}

// Implementaci√≥n JPA
@Component
public class VehiculoRepositoryAdapter implements VehiculoRepository {
    // Respeta el contrato: guardar() siempre retorna Vehiculo
    // buscarPorPlaca() siempre retorna Optional<Vehiculo>
}

// Futura implementaci√≥n MongoDB (ejemplo)
@Component  
public class VehiculoMongoAdapter implements VehiculoRepository {
    // DEBE respetar el mismo contrato y comportamiento
    // No puede lanzar excepciones diferentes
    // Debe mantener las mismas postcondiciones
}
```

**üéØ Sustituci√≥n de Casos de Uso**
```java
// El controller funciona con cualquier implementaci√≥n de ParqueaderoUseCase
@RestController
public class ParqueaderoController {
    private final ParqueaderoUseCase parqueaderoUseCase; // Interface
    
    // Puede ser ParqueaderoService, ParqueaderoServiceAdvanced, etc.
}
```

#### ‚ùå **Violaci√≥n que se evita:**
```java
// MAL - Violaci√≥n LSP
public class VehiculoBadRepository implements VehiculoRepository {
    public Vehiculo guardar(Vehiculo vehiculo) {
        throw new UnsupportedOperationException(); // ¬°Rompe LSP!
    }
}
```

---

### 4Ô∏è‚É£ **I** - Interface Segregation Principle (ISP)
> **"Los clientes no deben depender de interfaces que no utilizan"**

#### ‚úÖ **Aplicaci√≥n en el Proyecto:**

**üéØ Separaci√≥n de Puertos por Responsabilidad**

En lugar de una interfaz monol√≠tica, tenemos interfaces espec√≠ficas:

```java
// ‚úÖ CORRECTO - Interface espec√≠fica para casos de uso
public interface ParqueaderoUseCase {
    Vehiculo ingresarVehiculo(String placa, TipoVehiculo tipo);
    Vehiculo sacarVehiculo(String placa);
    List<Vehiculo> consultarVehiculosActivos();
    List<Vehiculo> consultarHistorial();
    int calcularCosto(String placa);
    // Solo m√©todos relacionados con parqueadero
}

// ‚úÖ CORRECTO - Interface espec√≠fica para persistencia
public interface VehiculoRepository {
    Vehiculo guardar(Vehiculo vehiculo);
    Optional<Vehiculo> buscarPorPlaca(String placa);
    List<Vehiculo> buscarVehiculosActivos();
    List<Vehiculo> buscarTodos();
    void eliminar(String placa);
    // Solo m√©todos relacionados con persistencia de veh√≠culos
}
```

#### üöÄ **Ejemplo de Segregaci√≥n Futura:**

Si el sistema crece, podr√≠amos segregar m√°s:

```java
// Interface segregada para consultas
public interface VehiculoConsultaUseCase {
    List<Vehiculo> consultarVehiculosActivos();
    List<Vehiculo> consultarHistorial();
}

// Interface segregada para operaciones
public interface VehiculoOperacionUseCase {
    Vehiculo ingresarVehiculo(String placa, TipoVehiculo tipo);
    Vehiculo sacarVehiculo(String placa);
}

// Interface segregada para c√°lculos
public interface CostoCalculoUseCase {
    int calcularCosto(String placa);
}
```

#### ‚ùå **Violaci√≥n que se evita:**
```java
// ‚ùå MAL - Interface monol√≠tica que viola ISP
public interface SuperParqueaderoInterface {
    // M√©todos de veh√≠culos
    Vehiculo ingresarVehiculo(String placa, TipoVehiculo tipo);
    
    // M√©todos de usuarios (no usados por VehiculoController)
    Usuario crearUsuario(String nombre);
    
    // M√©todos de facturaci√≥n (no usados por VehiculoService)
    Factura generarFactura(String vehiculoId);
    
    // M√©todos de reportes (no usados por la mayor√≠a)
    Reporte generarReporte();
}
```

---

### 5Ô∏è‚É£ **D** - Dependency Inversion Principle (DIP)
> **"Depender de abstracciones, no de implementaciones concretas"**

#### ‚úÖ **Aplicaci√≥n en el Proyecto:**

**üéØ Inversi√≥n de Dependencias en Capas**

```java
// ‚úÖ CAPA DE APLICACI√ìN - Depende de abstracci√≥n del dominio
@RestController
public class ParqueaderoController {
    private final ParqueaderoUseCase parqueaderoUseCase; // ‚Üê ABSTRACCI√ìN
    // NO depende de ParqueaderoService directamente
}

// ‚úÖ CAPA DE DOMINIO - Depende de abstracci√≥n de infraestructura  
@Service
public class ParqueaderoService implements ParqueaderoUseCase {
    private final VehiculoRepository vehiculoRepository; // ‚Üê ABSTRACCI√ìN
    // NO depende de VehiculoRepositoryAdapter directamente
}

// ‚úÖ CAPA DE INFRAESTRUCTURA - Implementa abstracciones del dominio
@Component
public class VehiculoRepositoryAdapter implements VehiculoRepository {
    private final VehiculoJpaRepository jpaRepository; // ‚Üê Spring Data abstraction
    // Implementa la abstracci√≥n del dominio
}
```

**üéØ Flujo de Dependencias (DIP en Acci√≥n):**

```mermaid
graph TD
    A[ParqueaderoController] -.->|depende de| B[ParqueaderoUseCase]
    B <-.-|implementa| C[ParqueaderoService]
    C -.->|depende de| D[VehiculoRepository]
    D <-.-|implementa| E[VehiculoRepositoryAdapter]
    
    style B fill:#4CAF50
    style D fill:#4CAF50
    
    classDef abstraction fill:#222,stroke:#2E7D32,stroke-width:2px
    classDef implementation fill:#333,stroke:#F57C00,stroke-width:2px
    
    class B,D abstraction
    class A,C,E implementation
```

**üéØ Configuraci√≥n de Spring (Inversi√≥n de Control)**

```java
// Spring automatically wires dependencies
@Service
public class ParqueaderoService implements ParqueaderoUseCase {
    // Spring inyecta autom√°ticamente VehiculoRepositoryAdapter
    private final VehiculoRepository vehiculoRepository;
}

@Component  
public class VehiculoRepositoryAdapter implements VehiculoRepository {
    // Spring inyecta autom√°ticamente VehiculoJpaRepository
    private final VehiculoJpaRepository jpaRepository;
}
```

#### ‚ùå **Violaci√≥n que se evita:**
```java
// ‚ùå MAL - Dependencia directa de implementaci√≥n concreta
@Service
public class BadParqueaderoService {
    private VehiculoRepositoryAdapter adapter; // ‚Üê IMPLEMENTACI√ìN CONCRETA
    
    public BadParqueaderoService() {
        this.adapter = new VehiculoRepositoryAdapter(); // ‚Üê ACOPLAMIENTO FUERTE
    }
}
```

---

## üèóÔ∏è SOLID en Arquitectura Hexagonal - Vista Integral

### üìä Mapa de Principios por Capas

```mermaid
graph TB
    subgraph "üåê Application Layer"
        direction TB
        AC[ParqueaderoController<br/>üìç SRP: Solo maneja HTTP<br/>üìç DIP: Depende de UseCase]
        DTO[DTOs<br/>üìç SRP: Solo transferencia de datos]
    end
    
    subgraph "üéØ Domain Layer (Hex√°gono)"
        direction TB
        UC[ParqueaderoUseCase<br/>üìç ISP: Interface espec√≠fica<br/>üìç OCP: Abierto para extensi√≥n]
        SV[ParqueaderoService<br/>üìç SRP: Solo l√≥gica de negocio<br/>üìç LSP: Sustituible<br/>üìç DIP: Depende de Repository]
        MD[Vehiculo Model<br/>üìç SRP: Solo dominio de veh√≠culo<br/>üìç OCP: Extensible via enum]
        RP[VehiculoRepository<br/>üìç ISP: Interface espec√≠fica<br/>üìç OCP: M√∫ltiples implementaciones]
    end
    
    subgraph "üîß Infrastructure Layer"
        direction TB
        AD[VehiculoRepositoryAdapter<br/>üìç SRP: Solo adaptaci√≥n<br/>üìç LSP: Sustituible<br/>üìç DIP: Implementa abstracci√≥n]
        JPA[VehiculoJpaRepository<br/>üìç SRP: Solo persistencia JPA]
    end
    
    AC -.->|DIP| UC
    UC <-.-|LSP| SV
    SV -.->|DIP| RP
    RP <-.-|LSP| AD
    AD --> JPA
    
    classDef solidS fill:#E3F2FD,stroke:#1976D2,stroke-width:2px
    classDef solidO fill:#E8F5E8,stroke:#388E3C,stroke-width:2px
    classDef solidL fill:#FFF3E0,stroke:#F57C00,stroke-width:2px
    classDef solidI fill:#F3E5F5,stroke:#7B1FA2,stroke-width:2px
    classDef solidD fill:#FFEBEE,stroke:#D32F2F,stroke-width:2px
```

### üéØ Beneficios de SOLID en Arquitectura Hexagonal

| Principio | Beneficio en Hexagonal | Ejemplo Concreto |
|-----------|------------------------|------------------|
| **SRP** | Cada capa tiene responsabilidad √∫nica | Controller solo HTTP, Service solo l√≥gica, Adapter solo conversi√≥n |
| **OCP** | Nuevos adaptadores sin modificar dominio | Nuevo `MongoRepositoryAdapter` sin tocar `ParqueaderoService` |
| **LSP** | Adaptadores intercambiables | Cambiar de JPA a MongoDB transparentemente |
| **ISP** | Puertos espec√≠ficos por funcionalidad | `ParqueaderoUseCase` vs `NotificacionUseCase` separados |
| **DIP** | Dominio independiente de infraestructura | Service depende de `VehiculoRepository`, no de `JpaRepository` |

---

## üöÄ Casos de Uso Futuros - SOLID Facilita Extensi√≥n

### 1. **Nuevo Tipo de Persistencia (OCP + LSP + DIP)**
```java
// Sin modificar c√≥digo existente
@Component
public class VehiculoRedisAdapter implements VehiculoRepository {
    // Nueva implementaci√≥n para cache Redis
}
```

### 2. **Nuevos Casos de Uso (SRP + ISP + OCP)**
```java
// Nueva funcionalidad sin afectar existente
public interface NotificacionUseCase {
    void notificarIngresoVehiculo(Vehiculo vehiculo);
}

@Service
public class NotificacionService implements NotificacionUseCase {
    // L√≥gica de notificaciones separada
}
```

### 3. **Nuevo Adaptador de Entrada (DIP + SRP)**
```java
// GraphQL Controller sin modificar Service
@Controller
public class ParqueaderoGraphQLController {
    private final ParqueaderoUseCase parqueaderoUseCase; // Misma abstracci√≥n
}
```

---

## ‚úÖ Conclusiones

Los principios **SOLID** est√°n profundamente integrados en la **Arquitectura Hexagonal**:

1. **üéØ SRP**: Cada elemento tiene una responsabilidad clara y √∫nica
2. **üîì OCP**: Los puertos permiten extensi√≥n sin modificaci√≥n  
3. **üîÑ LSP**: Los adaptadores son intercambiables manteniendo el comportamiento
4. **‚úÇÔ∏è ISP**: Los puertos est√°n segregados por funcionalidad espec√≠fica
5. **üîÄ DIP**: Las capas dependen de abstracciones, creando un sistema desacoplado

Esta combinaci√≥n resulta en un c√≥digo **mantenible**, **testeable** y **extensible** que facilita el desarrollo de microservicios robustos.
